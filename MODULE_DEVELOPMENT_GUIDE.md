# ðŸ“š Module Development Guide

**Version:** 1.0.0  
**Last Updated:** October 2025  
**Target Audience:** Module and Plugin Developers

---

**Copyright Â© 2025 AGP Studios, INC. All rights reserved.**

---

## ðŸ“‹ Table of Contents

1. [Introduction](#introduction)
2. [Getting Started](#getting-started)
3. [Module Types](#module-types)
4. [Creating Your First Module](#creating-your-first-module)
5. [Module Interface Reference](#module-interface-reference)
6. [Plugin Development](#plugin-development)
7. [Best Practices](#best-practices)
8. [Testing Your Module](#testing-your-module)
9. [Deployment](#deployment)
10. [Examples](#examples)
11. [Troubleshooting](#troubleshooting)
12. [Resources](#resources)

---

## Introduction

### What is a Module?

A **module** in RaOS is an independent unit of functionality that extends the platform's capabilities. Modules can be:
- **Built-in**: Compiled into RaCore (permanent)
- **External**: Separate DLL files (hot-swappable)
- **Plugins**: Extensions for existing modules (CMS plugins)

### Why Create Modules?

- **Extend Functionality**: Add new features without modifying core code
- **Reusability**: Share modules across multiple RaOS installations
- **Isolation**: Bugs in modules don't crash the entire system
- **Hot-Swap**: Update modules without restarting the server (external DLLs)
- **Monetization**: Sell modules in the planned marketplace

### Prerequisites

Before you start developing modules, you should have:

- **.NET 9.0 SDK** installed
- **Visual Studio 2022** or **VS Code** with C# extension
- **Basic C# knowledge** (async/await, interfaces, classes)
- **Familiarity with RaOS** (try running RaCore first)
- **Git** for version control

---

## Getting Started

### Setting Up Your Development Environment

1. **Clone the RaOS Repository**
   ```bash
   git clone https://github.com/buffbot88/TheRaProject.git
   cd TheRaProject
   ```

2. **Open in Visual Studio**
   ```bash
   # Open the solution file
   TheRaProject.sln
   ```

3. **Build the Solution**
   ```bash
   dotnet build
   ```

4. **Run RaCore**
   ```bash
   cd RaCore
   dotnet run
   ```

5. **Verify Setup**
   - RaCore should start on port 80
   - Console shows "Kawaii Boot Sequence"
   - Type `help` to see available commands

### Understanding the Project Structure

```
TheRaProject/
â”œâ”€â”€ Abstractions/              # Shared interfaces and models
â”‚   â”œâ”€â”€ IModule.cs            # Core module interface
â”‚   â””â”€â”€ Phase6*.cs            # Future module interfaces
â”œâ”€â”€ RaCore/                   # Main application
â”‚   â”œâ”€â”€ Program.cs            # Entry point
â”‚   â”œâ”€â”€ Engine/
â”‚   â”‚   â””â”€â”€ Manager/
â”‚   â”‚       â””â”€â”€ ModuleManager.cs  # Module loader
â”‚   â””â”€â”€ Modules/              # Built-in modules
â”‚       â”œâ”€â”€ Core/             # Core modules (5)
â”‚       â”œâ”€â”€ Extensions/       # Extension modules (29+)
â”‚       â”œâ”€â”€ Handlers/
â”‚       â”œâ”€â”€ Speech/
â”‚       â”œâ”€â”€ Conscious/
â”‚       â””â”€â”€ Subconscious/
â”œâ”€â”€ LegendaryCMS/             # External CMS module (DLL)
â”œâ”€â”€ LegendaryGameEngine/      # External game engine (DLL)
â”œâ”€â”€ LegendaryClientBuilder/   # External client builder (DLL)
â””â”€â”€ Modules/                  # Dynamically spawned modules (empty by default)
```

---

## Module Types

### 1. Built-in Modules

**Location**: `/RaCore/Modules/`

**Characteristics**:
- Compiled directly into RaCore assembly
- Cannot be updated without rebuilding RaCore
- Fastest performance (no DLL loading overhead)
- Best for core functionality

**When to Use**:
- Core system features
- Features that must always be available
- Performance-critical operations

**Example**: AuthenticationModule, MemoryModule, RaCoinModule

### 2. External DLL Modules

**Location**: Separate project, DLL copied to RaCore output

**Characteristics**:
- Independent class library (.csproj)
- Hot-swappable (can be updated independently)
- Loaded dynamically at runtime
- Slightly slower than built-in (DLL loading overhead)

**When to Use**:
- Large feature sets (CMS, Game Engine, Chat)
- UX modules that change frequently
- Optional modules (not everyone needs them)
- Third-party contributions

**Example**: LegendaryCMS, LegendaryGameEngine, LegendaryClientBuilder, LegendaryChat, LegendaryLearning, LegendaryGameServer, LegendaryGameClient

### 3. Dynamically Spawned Modules

**Location**: `/Modules/` (created at runtime)

**Characteristics**:
- Generated by ModuleSpawner at runtime
- Compiled on-the-fly using Roslyn
- Stored as source code and DLL
- Experimental feature (limited use)

**When to Use**:
- Rapid prototyping
- AI-generated modules
- Custom one-off modules

---

## Creating Your First Module

Let's create a simple "Hello World" external module.

### Step 1: Create a New Class Library

```bash
cd /path/to/TheRaProject
dotnet new classlib -n MyFirstModule
cd MyFirstModule
```

### Step 2: Add Project Reference

Edit `MyFirstModule.csproj`:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <!-- Reference the Abstractions project for IModule interface -->
    <ProjectReference Include="..\Abstractions\Abstractions.csproj" />
  </ItemGroup>
</Project>
```

### Step 3: Implement the Module

Create `MyFirstModule.cs`:

```csharp
using Abstractions;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace MyFirstModule
{
    public class MyFirstModule : IModule
    {
        // Module metadata
        public string Name => "MyFirstModule";
        public string Version => "1.0.0";
        public string Description => "My first RaOS module";
        public string Author => "Your Name";

        // Internal state
        private int _commandCount = 0;
        private DateTime _startTime;

        // Initialize the module
        public async Task<bool> InitializeAsync()
        {
            Console.WriteLine($"[{Name}] Initializing...");
            _startTime = DateTime.UtcNow;
            
            // Perform any setup here (e.g., connect to database, load config)
            await Task.Delay(100); // Simulate async initialization
            
            Console.WriteLine($"[{Name}] Initialized successfully!");
            return true; // Return false if initialization fails
        }

        // Process commands
        public async Task<string> ProcessAsync(string command, 
            Dictionary<string, object> context)
        {
            _commandCount++;
            
            // Parse the command
            if (command.StartsWith("hello"))
            {
                return await HandleHelloCommand(command, context);
            }
            else if (command == "myfirstmodule status")
            {
                return await HandleStatusCommand();
            }
            else if (command == "myfirstmodule help")
            {
                return HandleHelpCommand();
            }
            
            return $"Unknown command: {command}. Try 'myfirstmodule help'";
        }

        // Cleanup when shutting down
        public async Task ShutdownAsync()
        {
            Console.WriteLine($"[{Name}] Shutting down... Processed {_commandCount} commands");
            
            // Perform cleanup (e.g., close connections, save state)
            await Task.CompletedTask;
        }

        // Command handlers
        private async Task<string> HandleHelloCommand(string command, 
            Dictionary<string, object> context)
        {
            // Extract user from context (if available)
            var user = context.ContainsKey("user") ? context["user"].ToString() : "World";
            
            await Task.CompletedTask; // Placeholder for async operations
            return $"Hello, {user}! Welcome to MyFirstModule!";
        }

        private async Task<string> HandleStatusCommand()
        {
            var uptime = DateTime.UtcNow - _startTime;
            await Task.CompletedTask;
            
            return $@"MyFirstModule Status:
- Version: {Version}
- Uptime: {uptime.TotalSeconds:F2} seconds
- Commands Processed: {_commandCount}
- Status: Running";
        }

        private string HandleHelpCommand()
        {
            return @"MyFirstModule Commands:
- hello [name]           : Say hello
- myfirstmodule status   : Show module status
- myfirstmodule help     : Show this help";
        }
    }
}
```

### Step 4: Build the Module

```bash
dotnet build
```

Output: `MyFirstModule/bin/Debug/net9.0/MyFirstModule.dll`

### Step 5: Deploy to RaCore

```bash
# Copy DLL to RaCore output directory
cp bin/Debug/net9.0/MyFirstModule.dll ../RaCore/bin/Debug/net9.0/
```

### Step 6: Run RaCore and Test

```bash
cd ../RaCore
dotnet run
```

In the RaCore console:
```
> myfirstmodule status
MyFirstModule Status:
- Version: 1.0.0
- Uptime: 5.23 seconds
- Commands Processed: 1
- Status: Running

> hello Alice
Hello, Alice! Welcome to MyFirstModule!

> myfirstmodule help
MyFirstModule Commands:
- hello [name]           : Say hello
- myfirstmodule status   : Show module status
- myfirstmodule help     : Show this help
```

**Congratulations!** You've created your first RaOS module! ðŸŽ‰

---

## Module Interface Reference

### IModule Interface

```csharp
public interface IModule
{
    // Metadata
    string Name { get; }
    string Version { get; }
    
    // Lifecycle methods
    Task<bool> InitializeAsync();
    Task<string> ProcessAsync(string command, Dictionary<string, object> context);
    Task ShutdownAsync();
}
```

### Method Details

#### `InitializeAsync()`

**Purpose**: Initialize the module when it's first loaded.

**When Called**: Once, during module discovery and loading.

**Return Value**:
- `true` - Module initialized successfully, ready to use
- `false` - Initialization failed, module will not be loaded

**Best Practices**:
```csharp
public async Task<bool> InitializeAsync()
{
    try
    {
        // 1. Load configuration
        _config = await LoadConfigAsync();
        
        // 2. Connect to external services
        _database = await ConnectToDatabaseAsync();
        
        // 3. Validate dependencies
        if (_requiredModule == null)
        {
            Console.WriteLine($"[{Name}] Error: Required module not found");
            return false;
        }
        
        // 4. Log success
        Console.WriteLine($"[{Name}] Initialized successfully");
        return true;
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[{Name}] Initialization failed: {ex.Message}");
        return false;
    }
}
```

#### `ProcessAsync(command, context)`

**Purpose**: Handle commands and requests sent to the module.

**Parameters**:
- `command` (string): The command to process (e.g., "mymodule status", "mymodule create item")
- `context` (Dictionary<string, object>): Additional context data
  - `"user"` - User ID of the requester
  - `"session"` - Session ID
  - `"permissions"` - User permissions (future)
  - Custom keys added by other modules

**Return Value**: String response (JSON, plain text, or formatted message)

**Best Practices**:
```csharp
public async Task<string> ProcessAsync(string command, 
    Dictionary<string, object> context)
{
    try
    {
        // 1. Validate command
        if (string.IsNullOrWhiteSpace(command))
            return "Error: Empty command";
        
        // 2. Parse command
        var parts = command.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var moduleName = parts.Length > 0 ? parts[0] : "";
        var action = parts.Length > 1 ? parts[1] : "";
        
        // 3. Route to handler
        switch (action)
        {
            case "status":
                return await HandleStatusAsync();
            case "create":
                return await HandleCreateAsync(parts.Skip(2).ToArray(), context);
            default:
                return $"Unknown action: {action}";
        }
    }
    catch (Exception ex)
    {
        // 4. Handle errors gracefully
        Console.WriteLine($"[{Name}] Error processing command: {ex.Message}");
        return $"Error: {ex.Message}";
    }
}
```

#### `ShutdownAsync()`

**Purpose**: Cleanup when the module is being unloaded.

**When Called**: When RaCore is shutting down or module is being hot-reloaded.

**Best Practices**:
```csharp
public async Task ShutdownAsync()
{
    try
    {
        // 1. Save state
        await SaveStateAsync();
        
        // 2. Close connections
        _database?.Dispose();
        _httpClient?.Dispose();
        
        // 3. Cancel ongoing operations
        _cancellationTokenSource?.Cancel();
        
        // 4. Log shutdown
        Console.WriteLine($"[{Name}] Shut down successfully");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[{Name}] Error during shutdown: {ex.Message}");
    }
}
```

### Context Dictionary

The `context` parameter provides request context:

```csharp
// Access user information
var userId = context.ContainsKey("user") ? context["user"].ToString() : "anonymous";

// Access session ID
var sessionId = context.ContainsKey("session") ? context["session"].ToString() : null;

// Add custom data to context (for other modules)
context["mymodule_processed"] = true;
context["mymodule_result"] = someData;
```

---

## Plugin Development

### CMS Plugin System

The **LegendaryCMS** module supports plugins for extending CMS functionality.

### Plugin Interface

```csharp
public interface ICMSPlugin
{
    // Metadata
    string Name { get; }
    string Version { get; }
    string Description { get; }
    string Author { get; }
    
    // Lifecycle
    Task InitializeAsync(IPluginContext context);
    
    // Event hooks
    Task OnBeforeContentSaveAsync(ContentSaveContext context);
    Task OnAfterContentSaveAsync(ContentSaveContext context);
    Task OnBeforeContentDeleteAsync(ContentDeleteContext context);
    Task OnAfterContentDeleteAsync(ContentDeleteContext context);
    
    // Cleanup
    Task ShutdownAsync();
}
```

### Creating a CMS Plugin

#### Step 1: Create Plugin Class

```csharp
using LegendaryCMS.Plugins;
using System.Threading.Tasks;

namespace MyPlugin
{
    public class ContentValidatorPlugin : ICMSPlugin
    {
        public string Name => "Content Validator";
        public string Version => "1.0.0";
        public string Description => "Validates content before saving";
        public string Author => "Your Name";

        private IPluginContext _context;

        public async Task InitializeAsync(IPluginContext context)
        {
            _context = context;
            Console.WriteLine($"[{Name}] Plugin initialized");
            await Task.CompletedTask;
        }

        public async Task OnBeforeContentSaveAsync(ContentSaveContext context)
        {
            // Validate content
            if (string.IsNullOrWhiteSpace(context.Content))
            {
                context.Cancel = true;
                context.CancelReason = "Content cannot be empty";
                return;
            }

            // Check for profanity (simple example)
            var profanity = new[] { "badword1", "badword2" };
            foreach (var word in profanity)
            {
                if (context.Content.Contains(word, StringComparison.OrdinalIgnoreCase))
                {
                    context.Cancel = true;
                    context.CancelReason = $"Content contains prohibited word: {word}";
                    return;
                }
            }

            await Task.CompletedTask;
        }

        public async Task OnAfterContentSaveAsync(ContentSaveContext context)
        {
            // Log successful save
            Console.WriteLine($"[{Name}] Content saved: {context.ContentId}");
            await Task.CompletedTask;
        }

        public Task OnBeforeContentDeleteAsync(ContentDeleteContext context)
        {
            // Optional: prevent deletion of certain content
            return Task.CompletedTask;
        }

        public Task OnAfterContentDeleteAsync(ContentDeleteContext context)
        {
            return Task.CompletedTask;
        }

        public async Task ShutdownAsync()
        {
            Console.WriteLine($"[{Name}] Plugin shut down");
            await Task.CompletedTask;
        }
    }
}
```

#### Step 2: Create plugin.json

```json
{
  "name": "Content Validator",
  "version": "1.0.0",
  "description": "Validates content before saving",
  "author": "Your Name",
  "entryPoint": "MyPlugin.ContentValidatorPlugin",
  "dependencies": [],
  "permissions": [
    "cms.content.validate"
  ]
}
```

#### Step 3: Package as ZIP

```
MyPlugin.zip
â”œâ”€â”€ plugin.json
â”œâ”€â”€ MyPlugin.dll
â””â”€â”€ README.md
```

#### Step 4: Install via API

```bash
# Convert ZIP to base64
base64 -w 0 MyPlugin.zip > plugin_base64.txt

# Install via API
curl -X POST http://localhost:80/api/cms/plugin/install \
  -H "Content-Type: application/json" \
  -d '{
    "pluginPackage": "<base64_content>",
    "userId": "admin"
  }'
```

### Plugin Context (IPluginContext)

Plugins receive an `IPluginContext` that provides access to services:

```csharp
public interface IPluginContext
{
    // Access to module services
    IMemoryModule Memory { get; }
    IAuthenticationModule Auth { get; }
    IRBACManager RBAC { get; }
    
    // Configuration
    Dictionary<string, string> GetConfiguration();
    
    // Logging
    void Log(string message, LogLevel level);
}
```

**Example Usage**:
```csharp
public async Task OnAfterContentSaveAsync(ContentSaveContext context)
{
    // Log to memory module
    await _context.Memory.SetAsync(
        $"content:{context.ContentId}:saved_at", 
        DateTime.UtcNow.ToString());
    
    // Check permissions
    var hasPermission = await _context.RBAC.HasPermissionAsync(
        context.UserId, "cms.content.publish");
    
    // Log
    _context.Log($"Content saved by user {context.UserId}", LogLevel.Info);
}
```

---

## Best Practices

### 1. Error Handling

**Always** handle errors gracefully:

```csharp
public async Task<string> ProcessAsync(string command, 
    Dictionary<string, object> context)
{
    try
    {
        // Your code here
        return "Success";
    }
    catch (Exception ex)
    {
        // Log the error
        Console.WriteLine($"[{Name}] Error: {ex.Message}");
        
        // Return user-friendly error message
        return $"Error: {ex.Message}";
    }
}
```

**Never throw exceptions** from module methods - they can crash RaCore.

### 2. Async/Await

Use `async/await` for all I/O operations:

```csharp
// Bad: Blocking
var data = File.ReadAllText("config.json");

// Good: Async
var data = await File.ReadAllTextAsync("config.json");

// Bad: Blocking database query
var result = _database.Query("SELECT * FROM users").Result;

// Good: Async database query
var result = await _database.QueryAsync("SELECT * FROM users");
```

### 3. Resource Management

Always dispose of resources:

```csharp
public class MyModule : IModule
{
    private HttpClient _httpClient;
    private SqliteConnection _connection;
    
    public async Task<bool> InitializeAsync()
    {
        _httpClient = new HttpClient();
        _connection = new SqliteConnection("Data Source=mydb.db");
        await _connection.OpenAsync();
        return true;
    }
    
    public async Task ShutdownAsync()
    {
        // Dispose resources
        _httpClient?.Dispose();
        _connection?.Close();
        _connection?.Dispose();
    }
}
```

### 4. Configuration

Use external configuration files:

```csharp
public class MyModule : IModule
{
    private MyModuleConfig _config;
    
    public async Task<bool> InitializeAsync()
    {
        // Load from JSON file
        var configPath = Path.Combine("config", "mymodule.json");
        if (File.Exists(configPath))
        {
            var json = await File.ReadAllTextAsync(configPath);
            _config = JsonSerializer.Deserialize<MyModuleConfig>(json);
        }
        else
        {
            // Use defaults
            _config = new MyModuleConfig
            {
                ApiKey = "default",
                Timeout = 30
            };
        }
        
        return true;
    }
}
```

### 5. Logging

Use structured logging:

```csharp
// Good: Structured logging
Console.WriteLine($"[{Name}] {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} - INFO - User {userId} performed action {action}");

// Better: Use a logging library (future)
_logger.LogInformation("User {UserId} performed action {Action}", userId, action);
```

### 6. Versioning

Use semantic versioning (MAJOR.MINOR.PATCH):

```csharp
public string Version => "1.2.3";
// 1 = Major version (breaking changes)
// 2 = Minor version (new features, backward compatible)
// 3 = Patch version (bug fixes)
```

### 7. Module Dependencies

Access other modules safely:

```csharp
public async Task<bool> InitializeAsync()
{
    // Get required module
    _raCoinModule = _moduleManager.GetModule<RaCoinModule>();
    
    if (_raCoinModule == null)
    {
        Console.WriteLine($"[{Name}] Error: RaCoinModule is required but not loaded");
        return false; // Fail initialization
    }
    
    return true;
}
```

### 8. Thread Safety

Make your module thread-safe:

```csharp
public class MyModule : IModule
{
    private readonly object _lock = new object();
    private int _counter = 0;
    
    public async Task<string> ProcessAsync(string command, 
        Dictionary<string, object> context)
    {
        // Thread-safe increment
        lock (_lock)
        {
            _counter++;
        }
        
        // Or use concurrent collections
        // private ConcurrentDictionary<string, object> _cache = new();
    }
}
```

### 9. Performance

Optimize for performance:

```csharp
// Cache frequently accessed data
private Dictionary<string, (object Value, DateTime Expiry)> _cache = new();

public async Task<User> GetUserAsync(string userId)
{
    var cacheKey = $"user:{userId}";
    
    // Check cache first
    if (_cache.TryGetValue(cacheKey, out var cached) && 
        cached.Expiry > DateTime.UtcNow)
    {
        return (User)cached.Value;
    }
    
    // Fetch from database
    var user = await _database.GetUserAsync(userId);
    
    // Cache for 5 minutes
    _cache[cacheKey] = (user, DateTime.UtcNow.AddMinutes(5));
    
    return user;
}
```

### 10. Documentation

Document your module:

```csharp
/// <summary>
/// Manages user notifications and email delivery.
/// </summary>
public class NotificationModule : IModule
{
    /// <summary>
    /// Sends an email notification to a user.
    /// </summary>
    /// <param name="userId">The target user ID</param>
    /// <param name="subject">Email subject</param>
    /// <param name="body">Email body (HTML or plain text)</param>
    /// <returns>True if sent successfully, false otherwise</returns>
    public async Task<bool> SendEmailAsync(string userId, string subject, string body)
    {
        // Implementation
    }
}
```

---

## Testing Your Module

### Unit Testing

Create unit tests for your module:

```csharp
using Xunit;
using MyFirstModule;

public class MyFirstModuleTests
{
    [Fact]
    public async Task InitializeAsync_ShouldReturnTrue()
    {
        // Arrange
        var module = new MyFirstModule();
        
        // Act
        var result = await module.InitializeAsync();
        
        // Assert
        Assert.True(result);
    }
    
    [Fact]
    public async Task ProcessAsync_HelloCommand_ShouldReturnGreeting()
    {
        // Arrange
        var module = new MyFirstModule();
        await module.InitializeAsync();
        var context = new Dictionary<string, object>
        {
            ["user"] = "Alice"
        };
        
        // Act
        var result = await module.ProcessAsync("hello", context);
        
        // Assert
        Assert.Contains("Hello, Alice", result);
    }
}
```

### Integration Testing

Test your module with RaCore:

```bash
# 1. Build your module
dotnet build

# 2. Copy DLL to RaCore
cp bin/Debug/net9.0/MyFirstModule.dll ../RaCore/bin/Debug/net9.0/

# 3. Run RaCore
cd ../RaCore
dotnet run

# 4. Test commands in console
> myfirstmodule status
> hello World
```

### Automated Testing

Create a test script:

```bash
#!/bin/bash
# test_module.sh

echo "Building module..."
dotnet build || exit 1

echo "Copying DLL..."
cp bin/Debug/net9.0/MyFirstModule.dll ../RaCore/bin/Debug/net9.0/

echo "Running tests..."
dotnet test || exit 1

echo "All tests passed!"
```

---

## Deployment

### Development Deployment

For testing during development:

```bash
# Build module
dotnet build

# Copy to RaCore output
cp bin/Debug/net9.0/MyModule.dll ../RaCore/bin/Debug/net9.0/

# Restart RaCore
cd ../RaCore
dotnet run
```

### Production Deployment

For production use:

```bash
# Build in Release mode
dotnet build -c Release

# Copy to production server
scp bin/Release/net9.0/MyModule.dll user@server:/path/to/racore/

# On server: restart RaCore
ssh user@server "systemctl restart racore"
```

### NuGet Package (Future)

Planned support for distributing modules via NuGet:

```bash
# Pack as NuGet package
dotnet pack -c Release

# Publish to NuGet
dotnet nuget push bin/Release/MyModule.1.0.0.nupkg --api-key <key>

# Users can install
dotnet add package MyModule
```

### Module Marketplace (Planned - Phase 10)

Future marketplace for buying/selling modules:

1. Package module as `.zip` with metadata
2. Submit to marketplace via web portal
3. Automated security scanning and validation
4. Users browse and purchase
5. Automatic installation and updates

---

## Examples

### Example 1: Database Module

A module that provides database operations:

```csharp
using Abstractions;
using System.Data.SQLite;

public class DatabaseModule : IModule
{
    public string Name => "Database";
    public string Version => "1.0.0";
    
    private SQLiteConnection _connection;
    
    public async Task<bool> InitializeAsync()
    {
        _connection = new SQLiteConnection("Data Source=app.db");
        await _connection.OpenAsync();
        
        // Create tables if they don't exist
        var command = _connection.CreateCommand();
        command.CommandText = @"
            CREATE TABLE IF NOT EXISTS items (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                value INTEGER
            )";
        await command.ExecuteNonQueryAsync();
        
        return true;
    }
    
    public async Task<string> ProcessAsync(string command, 
        Dictionary<string, object> context)
    {
        var parts = command.Split(' ');
        
        if (parts[1] == "insert" && parts.Length >= 4)
        {
            // database insert <name> <value>
            return await InsertItemAsync(parts[2], int.Parse(parts[3]));
        }
        else if (parts[1] == "get" && parts.Length >= 3)
        {
            // database get <name>
            return await GetItemAsync(parts[2]);
        }
        
        return "Unknown command";
    }
    
    private async Task<string> InsertItemAsync(string name, int value)
    {
        var id = Guid.NewGuid().ToString();
        var command = _connection.CreateCommand();
        command.CommandText = "INSERT INTO items (id, name, value) VALUES ($id, $name, $value)";
        command.Parameters.AddWithValue("$id", id);
        command.Parameters.AddWithValue("$name", name);
        command.Parameters.AddWithValue("$value", value);
        
        await command.ExecuteNonQueryAsync();
        return $"Inserted item: {id}";
    }
    
    private async Task<string> GetItemAsync(string name)
    {
        var command = _connection.CreateCommand();
        command.CommandText = "SELECT value FROM items WHERE name = $name";
        command.Parameters.AddWithValue("$name", name);
        
        var reader = await command.ExecuteReaderAsync();
        if (await reader.ReadAsync())
        {
            var value = reader.GetInt32(0);
            return $"Value: {value}";
        }
        
        return "Item not found";
    }
    
    public async Task ShutdownAsync()
    {
        _connection?.Close();
        _connection?.Dispose();
        await Task.CompletedTask;
    }
}
```

### Example 2: HTTP Client Module

A module that makes HTTP requests:

```csharp
using Abstractions;
using System.Net.Http;
using System.Text.Json;

public class HttpClientModule : IModule
{
    public string Name => "HttpClient";
    public string Version => "1.0.0";
    
    private HttpClient _httpClient;
    
    public async Task<bool> InitializeAsync()
    {
        _httpClient = new HttpClient
        {
            Timeout = TimeSpan.FromSeconds(30)
        };
        return await Task.FromResult(true);
    }
    
    public async Task<string> ProcessAsync(string command, 
        Dictionary<string, object> context)
    {
        var parts = command.Split(' ', 3);
        
        if (parts[1] == "get" && parts.Length >= 3)
        {
            // httpclient get <url>
            return await GetAsync(parts[2]);
        }
        else if (parts[1] == "post" && parts.Length >= 3)
        {
            // httpclient post <url> <json>
            var url = parts[2];
            var json = parts.Length >= 4 ? parts[3] : "{}";
            return await PostAsync(url, json);
        }
        
        return "Unknown command. Usage: httpclient get <url> or httpclient post <url> <json>";
    }
    
    private async Task<string> GetAsync(string url)
    {
        try
        {
            var response = await _httpClient.GetAsync(url);
            response.EnsureSuccessStatusCode();
            var content = await response.Content.ReadAsStringAsync();
            return $"Response ({response.StatusCode}):\n{content}";
        }
        catch (Exception ex)
        {
            return $"Error: {ex.Message}";
        }
    }
    
    private async Task<string> PostAsync(string url, string jsonBody)
    {
        try
        {
            var content = new StringContent(jsonBody, System.Text.Encoding.UTF8, "application/json");
            var response = await _httpClient.PostAsync(url, content);
            response.EnsureSuccessStatusCode();
            var responseContent = await response.Content.ReadAsStringAsync();
            return $"Response ({response.StatusCode}):\n{responseContent}";
        }
        catch (Exception ex)
        {
            return $"Error: {ex.Message}";
        }
    }
    
    public async Task ShutdownAsync()
    {
        _httpClient?.Dispose();
        await Task.CompletedTask;
    }
}
```

### Example 3: Scheduled Task Module

A module that runs background tasks:

```csharp
using Abstractions;
using System.Threading;

public class SchedulerModule : IModule
{
    public string Name => "Scheduler";
    public string Version => "1.0.0";
    
    private Timer _timer;
    private int _taskCount = 0;
    
    public async Task<bool> InitializeAsync()
    {
        // Run task every 10 seconds
        _timer = new Timer(RunScheduledTask, null, 
            TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
        
        Console.WriteLine($"[{Name}] Scheduler started");
        return await Task.FromResult(true);
    }
    
    private void RunScheduledTask(object state)
    {
        _taskCount++;
        Console.WriteLine($"[{Name}] Running scheduled task #{_taskCount} at {DateTime.UtcNow}");
        
        // Perform your scheduled task here
        // Example: cleanup old data, send notifications, etc.
    }
    
    public async Task<string> ProcessAsync(string command, 
        Dictionary<string, object> context)
    {
        if (command == "scheduler status")
        {
            return $"Scheduler Status:\n- Tasks run: {_taskCount}\n- Next run: in ~10 seconds";
        }
        
        return "Unknown command";
    }
    
    public async Task ShutdownAsync()
    {
        _timer?.Dispose();
        Console.WriteLine($"[{Name}] Scheduler stopped. Total tasks run: {_taskCount}");
        await Task.CompletedTask;
    }
}
```

---

## Troubleshooting

### Common Issues

#### 1. Module Not Loading

**Symptom**: Module doesn't appear in `modules list`

**Solutions**:
- Check DLL is in correct location (`RaCore/bin/Debug/net9.0/`)
- Verify class implements `IModule` interface
- Check `InitializeAsync()` returns `true`
- Look for errors in RaCore console output

#### 2. "Type not found" Error

**Symptom**: `Could not find type 'MyModule' in assembly`

**Solutions**:
- Ensure namespace matches assembly name
- Check class is `public`
- Verify `.csproj` references Abstractions project
- Rebuild module and copy DLL again

#### 3. Module Crashes RaCore

**Symptom**: RaCore exits when module is loaded

**Solutions**:
- Check for unhandled exceptions in `InitializeAsync()`
- Wrap code in try-catch blocks
- Never throw exceptions from module methods
- Check for missing dependencies (NuGet packages)

#### 4. "Permission Denied" Errors

**Symptom**: Module can't access files or network

**Solutions**:
- Check file permissions
- Run RaCore with appropriate permissions
- Verify firewall allows connections
- Check antivirus isn't blocking

#### 5. Module Commands Not Working

**Symptom**: Commands return "Unknown command"

**Solutions**:
- Check command parsing in `ProcessAsync()`
- Verify command format matches expectations
- Add logging to debug command flow
- Test with simple commands first

### Debug Tips

#### Enable Verbose Logging

Add detailed logging to your module:

```csharp
public async Task<string> ProcessAsync(string command, 
    Dictionary<string, object> context)
{
    Console.WriteLine($"[{Name}] DEBUG: Command='{command}'");
    Console.WriteLine($"[{Name}] DEBUG: Context keys: {string.Join(", ", context.Keys)}");
    
    // Your code here
}
```

#### Use Debugger

Attach Visual Studio debugger to RaCore:

1. Start RaCore normally
2. In Visual Studio: Debug â†’ Attach to Process
3. Select `RaCore` process
4. Set breakpoints in your module code
5. Execute commands to hit breakpoints

#### Check Assembly Loading

Verify your DLL is loaded:

```csharp
// In module Initialize
var assembly = System.Reflection.Assembly.GetExecutingAssembly();
Console.WriteLine($"[{Name}] Loaded from: {assembly.Location}");
```

---

## Resources

### Documentation

- **ARCHITECTURE.md** - System architecture overview
- **ROADMAP.md** - Future features and plans
- **PHASES.md** - Completed phase history
- **README.md** - Project overview

### Module Examples

**External Legendary Modules**:
- **LegendaryCMS** - Full-featured CMS module
- **LegendaryGameEngine** - Game engine with chat
- **LegendaryClientBuilder** - Client generator
- **LegendaryChat** - Real-time chat system with moderation
- **LegendaryLearning** - Interactive learning/training (LULModule)
- **LegendaryGameServer** - AI-driven game creation
- **LegendaryGameClient** - Multi-platform game client generator

**Built-in Infrastructure Modules**:
- **RaCoinModule** - Virtual currency system
- **AuthenticationModule** - User authentication
- **LicenseModule** - License management

### Tools

- **Visual Studio 2022** - https://visualstudio.microsoft.com/
- **VS Code** - https://code.visualstudio.com/
- **.NET 9.0 SDK** - https://dotnet.microsoft.com/download
- **SQLite Browser** - https://sqlitebrowser.org/

### Community

- **GitHub Repository** - https://github.com/buffbot88/TheRaProject
- **Issues** - Report bugs and request features
- **Discussions** - Ask questions and share ideas

### Learning Resources

- **C# Programming Guide** - https://docs.microsoft.com/en-us/dotnet/csharp/
- **Async/Await Tutorial** - https://docs.microsoft.com/en-us/dotnet/csharp/async
- **SQLite Tutorial** - https://www.sqlitetutorial.net/

---

---

## Control Panel Integration (Phase 9.3.4)

### Overview

RaCore provides an Admin Control Panel with a modular, tabbed architecture. Your module can integrate seamlessly to provide a custom administrative interface.

### Benefits of Control Panel Integration

- **Centralized Management**: Single interface for all modules
- **Consistent UI/UX**: Inherit standard design patterns
- **Authentication Built-In**: Automatic role-based access control
- **API Integration**: Easy data exchange with backend
- **Real-Time Updates**: Support for live data refresh

### Quick Integration

#### Step 1: Mark Your Module

Ensure your module has the `[RaModule]` attribute:

```csharp
[RaModule(Category = "extensions")]
public class MyModule : ModuleBase
{
    public override string Name => "MyModule";
    // ...
}
```

#### Step 2: Add Tab Definition

Modify `RaCore/Modules/Extensions/SiteBuilder/WwwrootGenerator.cs`:

```csharp
// In GenerateControlPanelUiJs method, add to MODULE_TABS:
'MyModule': { 
    category: 'extensions',
    icon: 'ðŸŽ®',
    requiredRole: 'Admin',
    render: renderMyModuleTab
}
```

#### Step 3: Add Render Function

In the same file, add your render function:

```csharp
async function renderMyModuleTab(container) {{
    container.innerHTML = '<p class=\""loading\"">Loading...</p>';
    
    try {{
        const response = await fetch('/api/mymodule/status', {{
            headers: {{
                'Authorization': `Bearer ${{localStorage.getItem('racore_token')}}`
            }}
        }});
        
        const data = await response.json();
        
        container.innerHTML = `
            <h2 style=\""color: #667eea;\"">ðŸŽ® My Module</h2>
            <div class=\""stats-grid\"">
                <div class=\""stat-card\"">
                    <h3>${{data.count}}</h3>
                    <p>Items</p>
                </div>
            </div>
        `;
    }} catch (error) {{
        container.innerHTML = `<p class=\""error\"">Error: ${{error.message}}</p>`;
    }}
}}
```

#### Step 4: Add API Endpoint

In `RaCore/Program.cs`, add your endpoint:

```csharp
app.MapGet("/api/mymodule/status", async (HttpContext context) =>
{
    // 1. Check authentication
    if (authModule == null)
    {
        context.Response.StatusCode = 503;
        await context.Response.WriteAsJsonAsync(new { 
            success = false, 
            message = "Authentication not available" 
        });
        return;
    }

    // 2. Validate token and permissions
    var authHeader = context.Request.Headers["Authorization"].ToString();
    var token = authHeader.StartsWith("Bearer ") ? authHeader[7..] : authHeader;
    var user = await authModule.GetUserByTokenAsync(token);

    if (user == null || user.Role < UserRole.Admin)
    {
        context.Response.StatusCode = 403;
        await context.Response.WriteAsJsonAsync(new { 
            success = false, 
            message = "Insufficient permissions" 
        });
        return;
    }

    // 3. Get your module
    var myModule = moduleManager.Modules
        .Select(m => m.Instance)
        .OfType<MyModule>()
        .FirstOrDefault();

    if (myModule == null)
    {
        context.Response.StatusCode = 404;
        await context.Response.WriteAsJsonAsync(new { 
            success = false, 
            message = "Module not found" 
        });
        return;
    }

    // 4. Return module data
    await context.Response.WriteAsJsonAsync(new
    {
        success = true,
        count = myModule.GetItemCount(),
        status = "Operational"
    });
});
```

### UI Components

Use these standard components for consistency:

#### Stats Grid
```html
<div class="stats-grid">
    <div class="stat-card">
        <h3>123</h3>
        <p>Metric Name</p>
    </div>
</div>
```

#### Module Grid
```html
<div class="modules-grid">
    <div class="module-card">
        <h3>Feature Title</h3>
        <p>Description</p>
        <button onclick="handleAction()">Action</button>
    </div>
</div>
```

#### Status Badge
```html
<span class="module-status active">Active</span>
```

### Color Palette

```javascript
{
    primary: '#667eea',      // Purple
    success: '#10b981',      // Green
    warning: '#f59e0b',      // Orange
    error: '#ef4444',        // Red
    text: '#1a202c'          // Dark Text
}
```

### Advanced Features

#### Real-Time Updates

```javascript
async function renderMyModuleTab(container) {
    let updateInterval;
    
    const update = async () => {
        const data = await fetch('/api/mymodule/status', {
            headers: { 'Authorization': `Bearer ${localStorage.getItem('racore_token')}` }
        }).then(r => r.json());
        
        document.getElementById('count').textContent = data.count;
    };
    
    // Initial render
    container.innerHTML = `
        <div class="stat-card">
            <h3 id="count">0</h3>
            <p>Items</p>
        </div>
    `;
    
    await update();
    updateInterval = setInterval(update, 5000);
    
    container.addEventListener('removed', () => clearInterval(updateInterval));
}
```

### Complete Documentation

For comprehensive control panel integration documentation, see:

- **CONTROL_PANEL_MODULE_API.md** - Complete API reference
- **CONTROL_PANEL_DEVELOPER_GUIDE.md** - Step-by-step developer guide
- **LEGENDARY_CLIENTBUILDER_WEB_INTERFACE.md** - Example web interface
- **PHASE9_3_3_SUMMARY.md** - Control panel architecture

---

## Conclusion

You now have everything you need to create powerful modules for RaOS! Remember:

1. **Start Simple** - Begin with a basic module, then add features
2. **Test Thoroughly** - Test in development before deploying to production
3. **Follow Best Practices** - Error handling, async/await, resource management
4. **Document Your Code** - Help others (and future you) understand your module
5. **Share Your Work** - Contribute to the ecosystem (marketplace coming in Phase 10!)
6. **Integrate with Control Panel** - Provide an admin interface for your module

Happy coding! ðŸš€

---

**Last Updated**: January 2025  
**Version**: 1.0.1 (Phase 9.3.4)  
**Maintained By**: RaCore Development Team  
**Repository**: https://github.com/buffbot88/TheRaProject

**Questions?** Open an issue on GitHub or check the documentation.

---

**Copyright Â© 2025 AGP Studios, INC. All rights reserved.**
